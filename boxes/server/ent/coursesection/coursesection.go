// Code generated by ent, DO NOT EDIT.

package coursesection

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the coursesection type in the database.
	Label = "course_section"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldNumber holds the string denoting the number field in the database.
	FieldNumber = "number"
	// EdgeCourse holds the string denoting the course edge name in mutations.
	EdgeCourse = "course"
	// EdgeProfessors holds the string denoting the professors edge name in mutations.
	EdgeProfessors = "professors"
	// EdgeTeachingAssistants holds the string denoting the teaching_assistants edge name in mutations.
	EdgeTeachingAssistants = "teaching_assistants"
	// EdgeCourseAssistants holds the string denoting the course_assistants edge name in mutations.
	EdgeCourseAssistants = "course_assistants"
	// EdgeStudents holds the string denoting the students edge name in mutations.
	EdgeStudents = "students"
	// Table holds the table name of the coursesection in the database.
	Table = "course_sections"
	// CourseTable is the table that holds the course relation/edge.
	CourseTable = "course_sections"
	// CourseInverseTable is the table name for the Course entity.
	// It exists in this package in order to avoid circular dependency with the "course" package.
	CourseInverseTable = "courses"
	// CourseColumn is the table column denoting the course relation/edge.
	CourseColumn = "course_sections"
	// ProfessorsTable is the table that holds the professors relation/edge. The primary key declared below.
	ProfessorsTable = "user_teaching_sections"
	// ProfessorsInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	ProfessorsInverseTable = "users"
	// TeachingAssistantsTable is the table that holds the teaching_assistants relation/edge. The primary key declared below.
	TeachingAssistantsTable = "user_teaching_assistant_sections"
	// TeachingAssistantsInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	TeachingAssistantsInverseTable = "users"
	// CourseAssistantsTable is the table that holds the course_assistants relation/edge. The primary key declared below.
	CourseAssistantsTable = "user_course_assistant_sections"
	// CourseAssistantsInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	CourseAssistantsInverseTable = "users"
	// StudentsTable is the table that holds the students relation/edge. The primary key declared below.
	StudentsTable = "user_enrolled_sections"
	// StudentsInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	StudentsInverseTable = "users"
)

// Columns holds all SQL columns for coursesection fields.
var Columns = []string{
	FieldID,
	FieldNumber,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "course_sections"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"course_sections",
}

var (
	// ProfessorsPrimaryKey and ProfessorsColumn2 are the table columns denoting the
	// primary key for the professors relation (M2M).
	ProfessorsPrimaryKey = []string{"user_id", "course_section_id"}
	// TeachingAssistantsPrimaryKey and TeachingAssistantsColumn2 are the table columns denoting the
	// primary key for the teaching_assistants relation (M2M).
	TeachingAssistantsPrimaryKey = []string{"user_id", "course_section_id"}
	// CourseAssistantsPrimaryKey and CourseAssistantsColumn2 are the table columns denoting the
	// primary key for the course_assistants relation (M2M).
	CourseAssistantsPrimaryKey = []string{"user_id", "course_section_id"}
	// StudentsPrimaryKey and StudentsColumn2 are the table columns denoting the
	// primary key for the students relation (M2M).
	StudentsPrimaryKey = []string{"user_id", "course_section_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

// OrderOption defines the ordering options for the CourseSection queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByNumber orders the results by the number field.
func ByNumber(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNumber, opts...).ToFunc()
}

// ByCourseField orders the results by course field.
func ByCourseField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCourseStep(), sql.OrderByField(field, opts...))
	}
}

// ByProfessorsCount orders the results by professors count.
func ByProfessorsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newProfessorsStep(), opts...)
	}
}

// ByProfessors orders the results by professors terms.
func ByProfessors(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newProfessorsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByTeachingAssistantsCount orders the results by teaching_assistants count.
func ByTeachingAssistantsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newTeachingAssistantsStep(), opts...)
	}
}

// ByTeachingAssistants orders the results by teaching_assistants terms.
func ByTeachingAssistants(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTeachingAssistantsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByCourseAssistantsCount orders the results by course_assistants count.
func ByCourseAssistantsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newCourseAssistantsStep(), opts...)
	}
}

// ByCourseAssistants orders the results by course_assistants terms.
func ByCourseAssistants(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCourseAssistantsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByStudentsCount orders the results by students count.
func ByStudentsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newStudentsStep(), opts...)
	}
}

// ByStudents orders the results by students terms.
func ByStudents(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newStudentsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newCourseStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CourseInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, CourseTable, CourseColumn),
	)
}
func newProfessorsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ProfessorsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, ProfessorsTable, ProfessorsPrimaryKey...),
	)
}
func newTeachingAssistantsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TeachingAssistantsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, TeachingAssistantsTable, TeachingAssistantsPrimaryKey...),
	)
}
func newCourseAssistantsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CourseAssistantsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, CourseAssistantsTable, CourseAssistantsPrimaryKey...),
	)
}
func newStudentsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(StudentsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, StudentsTable, StudentsPrimaryKey...),
	)
}
